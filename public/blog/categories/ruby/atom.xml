<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Alessandro Dias]]></title>
  <link href="http://alessandrodias.herokuapp.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://alessandrodias.herokuapp.com/"/>
  <updated>2014-01-23T00:53:04-02:00</updated>
  <id>http://alessandrodias.herokuapp.com/</id>
  <author>
    <name><![CDATA[Alessandro Dias Batista]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cuidado ao chamar métodos da classe pai]]></title>
    <link href="http://alessandrodias.herokuapp.com/blog/2014/01/20/cuidado-ao-usar-super-em-seus-metodos/"/>
    <updated>2014-01-20T19:59:00-02:00</updated>
    <id>http://alessandrodias.herokuapp.com/blog/2014/01/20/cuidado-ao-usar-super-em-seus-metodos</id>
    <content type="html"><![CDATA[<p>Lendo um pouco sobre herança em Ruby descobri uma coisa interessante, ao usar o método <code>super</code> em algum método, pode ocorrer da erro caso o desenvolvedor não preste atenção. Quando você redefine um método e chama <code>super</code> sem parênteses e sem argumentos, o Ruby irá pegar os parâmetros passados para o método na subclasse passar de forma implícita para o método da superclasse, se os parâmetros do método na superclasse forem diferentes dos parâmetros no método redefinido irá resultar em erro.
Exemplo:</p>

<p>```ruby
class Dad
  def hi</p>

<pre><code>puts "Hello"
</code></pre>

<p>  end
end</p>

<p>Class Child &lt; Dad
  def hi</p>

<pre><code>super
puts "World"
</code></pre>

<p>  end
end</p>

<p>Child.new.hi</p>

<p>=> ArgumentError: wrong number of arguments (1 for 0)
```</p>

<p>Como resolver isso? Simples.
Caso o método da superclasse não receba parâmetros chame o método super com parênteses <code>super()</code>
Exemplo:</p>

<p>```ruby
class Dad
  def hi</p>

<pre><code>puts "Hello"
</code></pre>

<p>  end
end</p>

<p>Class Child &lt; Dad
  def hi</p>

<pre><code>super()
puts "World"
</code></pre>

<p>  end
end</p>

<p>Child.new.hi
Hello
World
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O que é o splat operator do ruby?]]></title>
    <link href="http://alessandrodias.herokuapp.com/blog/2013/09/15/o-que-e-o-splat-operator-do-ruby/"/>
    <updated>2013-09-15T13:25:00-03:00</updated>
    <id>http://alessandrodias.herokuapp.com/blog/2013/09/15/o-que-e-o-splat-operator-do-ruby</id>
    <content type="html"><![CDATA[<p>Esses dias olhando código no GitHub vi um trecho como esse: <code>def example(*b)</code>
O que esse código faz não vem ao caso, mas olhei o <code>*b</code> e pensei, oque que é esse * antes da variável me veio na hora ponteiro, mas ruby não possui ponteiros, então oque <code>*b</code> faz?
pesquisei sobre e resumindo é a sintaxe para splat operator em ruby, ex:</p>

<p>```ruby</p>

<pre><code>def example(*b)
  puts b
end

example 1,2,3,4 # =&gt; 1 2 3 4

arr = [5,6,7,8]
example *arr # =&gt; 5 6 7 8
</code></pre>

<p>```</p>

<p>na ultima linha o <code>*arr</code> faz com que cada item do array seja passado como parâmetro para o método <code>example</code>, você pode usar dessa forma também.</p>

<p>```ruby</p>

<pre><code>def example2(v1,v2,3)
  puts v1,v2,v3
end

arr = [2, 3, 1]
example2 *arr # =&gt; 2 3 1
</code></pre>

<p>```
Nessa segunda abordagem você de ter cuidado para que a quantidade de elementos no array seja igual a quantidade de parâmetros requeridos pelo método.</p>

<p>Outra forma válida é o próximo exemplo:</p>

<p>```ruby</p>

<pre><code>def example3(v1,*v2)
  puts v2
end

arr = [2, 3, 1]

example3 *arr #=&gt; 3 1
</code></pre>

<p>```</p>

<p>Nesse caso o primeiro valor da variavel <code>arr</code> é atribuido ao primeiro parâmetro e os demais ao parâmetro v2.</p>
]]></content>
  </entry>
  
</feed>
