<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Alessandro Dias]]></title>
  <link href="http://alessandrodias.herokuapp.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://alessandrodias.herokuapp.com/"/>
  <updated>2014-01-24T00:46:22-02:00</updated>
  <id>http://alessandrodias.herokuapp.com/</id>
  <author>
    <name><![CDATA[Alessandro Dias Batista]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[construtores em ruby]]></title>
    <link href="http://alessandrodias.herokuapp.com/blog/2014/01/23/construtores-em-ruby/"/>
    <updated>2014-01-23T15:53:00-02:00</updated>
    <id>http://alessandrodias.herokuapp.com/blog/2014/01/23/construtores-em-ruby</id>
    <content type="html"><![CDATA[<p>Você ja deve ter percebido que diferente do C#, Java e outras linguagens OO, em Ruby a criação de um novo objeto é feita pelo método <code>new</code>, mas como é feita a criação de um objeto em Ruby?
Primeiro faremos uma lista do que precisamos para para instanciar um novo objeto.</p>

<ol>
<li>Alocar espaço para um objeto vazio</li>
<li>Setar o estado inicial do objeto</li>
<li>Retornar a referência para o objeto alocado</li>
</ol>


<p>Após feita a lista vamos criar um objeto com um construtor personalizado com cada item da lista</p>

<p>```ruby
class Book
  def self.custom_new(title, author)</p>

<pre><code>instance = allocate # Aloca espaço para um novo objeto vazio
instance.custom_initialize(title, author)
instance # Retorna a referência do objeto
</code></pre>

<p>  end</p>

<p>  def custom_initialize(title, author)</p>

<pre><code>@title, @author = title, author
</code></pre>

<p>  end
end</p>

<p>Book.custom_new(&lsquo;Title&rsquo;,&lsquo;Alessandro&rsquo;)
 => #&lt;Book:0x00000003607978 @author=&ldquo;ale&rdquo;, @title=&ldquo;Title&rdquo;>
<code>``
No caso acima criamos uma classe</code>Book<code>que possui um construtor personalizado, claro que poderíamos sobrescrever o método</code>new<code>e/ou</code>initialize`, mas fiz dessa forma apena para mostrar que é possivel fazer assim.</p>

<p>Caso queira saber sobre o método <code>allocate</code> aqui está a <a href="http://www.ruby-doc.org/core-2.1.0/Class.html#method-i-allocate">documentação</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cuidado ao chamar métodos da classe pai]]></title>
    <link href="http://alessandrodias.herokuapp.com/blog/2014/01/20/cuidado-ao-usar-super-em-seus-metodos/"/>
    <updated>2014-01-20T19:59:00-02:00</updated>
    <id>http://alessandrodias.herokuapp.com/blog/2014/01/20/cuidado-ao-usar-super-em-seus-metodos</id>
    <content type="html"><![CDATA[<p>Lendo um pouco sobre herança em Ruby descobri uma coisa interessante, ao usar o método <code>super</code> em algum método, pode ocorrer da erro caso o desenvolvedor não preste atenção. Quando você redefine um método e chama <code>super</code> sem parênteses e sem argumentos, o Ruby irá pegar os parâmetros passados para o método na subclasse passar de forma implícita para o método da superclasse, se os parâmetros do método na superclasse forem diferentes dos parâmetros no método redefinido irá resultar em erro.
Exemplo:</p>

<p>```ruby
class Dad
  def hi</p>

<pre><code>puts "Hello"
</code></pre>

<p>  end
end</p>

<p>Class Child &lt; Dad
  def hi</p>

<pre><code>super
puts "World"
</code></pre>

<p>  end
end</p>

<p>Child.new.hi</p>

<p>=> ArgumentError: wrong number of arguments (1 for 0)
```</p>

<p>Como resolver isso? Simples.
Caso o método da superclasse não receba parâmetros chame o método super com parênteses <code>super()</code>
Exemplo:</p>

<p>```ruby
class Dad
  def hi</p>

<pre><code>puts "Hello"
</code></pre>

<p>  end
end</p>

<p>Class Child &lt; Dad
  def hi</p>

<pre><code>super()
puts "World"
</code></pre>

<p>  end
end</p>

<p>Child.new.hi
Hello
World
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O que é o splat operator do ruby?]]></title>
    <link href="http://alessandrodias.herokuapp.com/blog/2013/09/15/o-que-e-o-splat-operator-do-ruby/"/>
    <updated>2013-09-15T13:25:00-03:00</updated>
    <id>http://alessandrodias.herokuapp.com/blog/2013/09/15/o-que-e-o-splat-operator-do-ruby</id>
    <content type="html"><![CDATA[<p>Esses dias olhando código no GitHub vi um trecho como esse: <code>def example(*b)</code>
O que esse código faz não vem ao caso, mas olhei o <code>*b</code> e pensei, oque que é esse * antes da variável me veio na hora ponteiro, mas ruby não possui ponteiros, então oque <code>*b</code> faz?
pesquisei sobre e resumindo é a sintaxe para splat operator em ruby, ex:</p>

<p>```ruby</p>

<pre><code>def example(*b)
  puts b
end

example 1,2,3,4 # =&gt; 1 2 3 4

arr = [5,6,7,8]
example *arr # =&gt; 5 6 7 8
</code></pre>

<p>```</p>

<p>na ultima linha o <code>*arr</code> faz com que cada item do array seja passado como parâmetro para o método <code>example</code>, você pode usar dessa forma também.</p>

<p>```ruby</p>

<pre><code>def example2(v1,v2,3)
  puts v1,v2,v3
end

arr = [2, 3, 1]
example2 *arr # =&gt; 2 3 1
</code></pre>

<p>```
Nessa segunda abordagem você de ter cuidado para que a quantidade de elementos no array seja igual a quantidade de parâmetros requeridos pelo método.</p>

<p>Outra forma válida é o próximo exemplo:</p>

<p>```ruby</p>

<pre><code>def example3(v1,*v2)
  puts v2
end

arr = [2, 3, 1]

example3 *arr #=&gt; 3 1
</code></pre>

<p>```</p>

<p>Nesse caso o primeiro valor da variavel <code>arr</code> é atribuido ao primeiro parâmetro e os demais ao parâmetro v2.</p>
]]></content>
  </entry>
  
</feed>
